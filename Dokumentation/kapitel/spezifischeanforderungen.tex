\section{Spezifische Anforderungen}
\subsection{Strukturierte Analyse}
\subsubsection{Kontextdiagramm}
\begin{figure}[H]
	\centering
  \includegraphics[width=\textwidth]{DFD/kontextdiagramm.png}
	\caption{Kontextdiagramm}
	\label{fig1}
\end{figure}
Aus dem Kontextdiagramm lässt sich leicht erkennen, dass das System aus zwei großen Teilen besteht. Auf der einen Seite ist sdie HRL-Steuerung, welche Eingaben erfasst, kontrolliert und die gewünschte Reaktion darauf berechnet. Auf der anderen Seite steht die Simulation, die für die physikalischen Abläufe nötige Zeit und das auslösen der diversen Sensoren simuliert. Verbunden sind beide durch diverse MessageQueues und eine globale Variable, welche in den weiteren Datenflussdiagrammen erleutert werden.
\subsubsection{DFD1 Simulation}
\begin{figure}[H]
	\centering
  \includegraphics[width=\textwidth]{DFD/dfd1_simulation1_1.png}
	\caption{DFD1 Simulation}
	\label{fig2}
\end{figure}
\underline{Mini-Spec Simulation Beweger:}\\
Beweger setzt virtuelle Position(Positionsdaten) nach Aktordaten(abusdata), welche durch Semaphore geschützt werden\\ \\
 if(x nach rechts) virtuelle Position-X ++\\
else if(x nach links) virtuelle Position-X - -\\
if(y nach oben) virtuelle Position-Y - -\\
else if(y nach unten) virtuelle Position-Y ++\\
if(z nach vorne) virtuelle Position-Z ++\\
else if(z nach hinten) virtuelle Position-Z - -\\ \\

\underline{Mini-Spec Simulation Sensor 0-22:}\\
Sensor Task berechnet eigenes trifferoffset und gleicht dieses mit virtueller Position ab\\
if(virtuelle Position-X == triggeroffset-X) true und eigene ID in msgQueueIdSensorCollector\\
else false und eigene ID in msgQueueIdSensorCollector\\ \\
analog für Y- und Z-Sensoren\\ \\

\underline{Mini-Spec Simulation Sensor 23-25:}\\
Sensoren für Lichttaster.
Berechnung nicht über triggeroffset, sondern Lichtschranken werden über Zeitkonstanten gesteuert, welche hoch bzw. runter gezählt werden.\\
Setzen bzw. Entfernen eines Klötzchens aus bzw. in einen Lichttaster:\\ \\
if(Z = in Regal und Y= hoch) \\
Auslagerungsvorgang in Regal erkannt -> Lichttaster anschließend bedeckt und Belegungsmatrix[X][Y]= nicht belegt\\
\\
if(Z = in Regal und Y= runter)\\
Einlagerungsvorgang in Regal erkannt -> Lichttaster anschließend nicht bedeckt und Belegungsmatrix[X][Y] = belegt \\
\\
\\
if(Z = aus Regal heraus und Y= hoch)\\
Aufnahmevorgang in Eingabe-Slot erkannt -> Lichttaster anschließend bedeckt und Zeitkonstante von Lichtschrank in Slot wird zurückgesetzt\\
\\
if(Z = aus Regal heraus und Y= runter)\\
Auslagerungsvorgang in Ausgabe-Slot erkannt -> Lichttaster anschließend nicht bedeckt  Zeitkonstante von Lichtschrank in Slot wird zurückgesetzt\ \\
\\
\\
\underline{Mini-Spec Sensorcollector:}\\
Sensorcollector greift Datensatz aus msgQueueIdSensorCollector ab(leeren der Queue), fügt sie zu sbusdata zusammen und gibt diese in msgQueueIdSensorData\\ 


\subsubsection{DFD1 Steuerung}
\begin{figure}[H]
	\centering
  \includegraphics[width=\textwidth]{DFD/dfd1_steuerung.png}
	\caption{DFD1 Steuerung}
	\label{fig3}
\end{figure}

\underline{Mini-Spec Movement:}\\
Der Movement-Task fragt kontinuierlich nach neuem Auftrag aus msgQueueCMD, ist keiner da wird Timeout ausgelöst und System geht in Pause-Modus bzw. Zusatzaufgabe über. Wenn Auftrag bereitsteht wird Belegung geändert(für Befehle vsetspace und clearspace) bzw. es werden die 8 Teilsensorbilder generiert(Befehle insert und remove). Diese werden in msgQueueNextMovement weitergeleitet und werden anschließend nacheinander abgearbeitet (aus der Queue). Für jeden Teilauftrag wird auf neue Sensordaten aus msgQueueSensor gewartet und die daraus entstehenden aktuellen Sensordaten mit den Soll-Sensordaten verglichen, dabei werden alle neuen Sensordaten auf ihre Legitimität überprüft und im Fehlerfall (z.B. blockierte Schiene) werden alle Motoren gestoppt und das System angehalten. Die Aktordoten werden in die msgQueueAktorPush geleitet. \\

\underline{Mini-Spec AktorDataPush:}
AktorDataPush dient zur Weitervermittlung der Aktordaten, welche geschützt weitergeleitet werden müssen(globale Variable).
Wartet auf Aktordaten in msgQueueAktorPush, sind welche vorhanden wartet er auf die Semaphore um anschließend in die globale Variable zu schreiben aus welcher die Simulation liest. Für diese Semaphore wurde eine Prioritätsvererbung implementiert um den Schreibvorgang auf die globale Variable möglichst nicht aus zu bremsen. \\


\subsection {Funktionale Anforderungen}

\paragraph{Beweger}
Wie in Abb.\ref{gantt} zu sehen ist läuft der \textbf{Beweger} als erster Task eines Simulationsschrittes. Zuerst aktualisiert er die Aktorwerte aus der gloablen Variable \textbf{AktorBusData}. Diese entspricht den Busdaten und ist durch eine Semaphore geschützt. Da die Simulation minimal blockiert werden soll implementiert die Semaphore eine Prioritätsvererbung. Daraufhin \glqq verschiebt\grqq   er den virtuellen Turm entsprechend der Aktordaten.

\paragraph{Sensorcollector}
Der \textbf{Sensorcollector} läuft nach allen Sensoren und sammelt  aus einer Message Queue die Einträge aller Sensoren. Wenn ein Sensor ausfällt bleibt der Wert des Sensors auf 1. Daraufhin schiebt er alle Sensorwerte, in einem Vektor, in eine Messega Queue auf die die Steuerung Zugriff hat.

\paragraph{Simulation Sensor x}
Jeder Sensor bekommt eine id übergeben die seine Funktion und ihn eindeutig definiert. 
\begin{enumerate} 
\item \textbf{Tastsensoren} überprüfen ob die Turmposition mit der Sensorposition übereinstimmt.
\item \textbf{Lichtschranken} Simulieren entweder das eintreffen eines Klötzchens am Eingabeslot oder das Entfernen eines Klötzchens am Ausgabeslot, jeweils mit einem vordefinierten Delay.
\item Der \textbf{Lichttaster} im Turm wird dann ausgelöst wenn die vorige y-Position des Turms im vorigen Schritt über (beim Ablegen eines Klötzchens) bzw. unter (beim Aufnehmen) der jetzigen Position ist und (beim Ablegen) ein Klötzchen im Turm ist bzw. (beim Aufnehmen) ein Klötzchen an der Aufnahmeposition ist.
\end{enumerate}
Die jeweiligen Sensordaten schiebt der Task daraufhin in eine Message Queue für den Sensorcollector.

\begin{figure}[H]
	\centering
  \includegraphics[width=\textwidth]{diagrams/gand.png}
	\caption{Gantt Diagramm der Task der Simulation}
	\label{gantt}
\end{figure}

Alle Tasks in der Simulation haben eine Priorität von 200 und ändern diese nicht. Sie werden in einer festen Reihenfolge erzeugt und laufen dann in jedem Zyklus in dieser Sequenz.

\begin{table}[h]
\centering
\begin{tabular}{|l|r|}
\hline
Taster X[0-9] &  [gedrückt|gehalten] \\
\hline
Taster Y[0-9] &  [gedrückt|gehalten] \\
\hline
Taster Z[0-3] &  [gedrückt|gehalten] \\
\hline
Lichtschranke Eingabe & [unterbrochen|nicht unterbrochen] \\
\hline
Lichtschranke Ausgabe & [unterbrochen|nicht unterbrochen] \\
\hline
Turmlichtschalter & [bedeckt|nicht bedeckt]\\
\hline
\end{tabular}
\caption{Requirements Dictionary: Die Stati der Sensoren}
\label{tab:Requirements Dictionary}
\end{table}
